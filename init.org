#+title: init.org
#+property: header-args:emacs-lisp :tangle ~/.emacs.d/init.el

* Preface | 前言

** My Usage of Emacs | 我使用 Emacs 来做什麼

I use Emacs mainly in WSL (Windows Subsystem for Linux) for

- Using [[https://orgmode.org/][org-mode]], [[https://www.orgroam.com/][org-roam]], [[https://github.com/bastibe/org-journal][org-journal]], and other org utilities.
- Writing documents in: LaTeX, markdown, org.
- Coding in: Python.

** How to Install | 如何安裝

Press =C-c C-v t= (~org-babel-tangle~) while reading this file inside Emacs, to generate the actual
configuration file, ~init.el~. Relaunch Emacs to load the configuration file.

Alternatively, you can use this command in Shell to generate the configuration file: (replace "/path/to/init.org" with the actual path of this file)

#+begin_src shell
  emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "/path/to/init.org")'
#+end_src

** Naming Conventions | 命名慣例

This section is inspired by [[https://docs.doomemacs.org/latest/#/developers/conventions/emacs-lisp/naming-conventions][Doom Emacs naming conventions]].

Symbol names starts with ~NAMESPACE~, where ~NAMESPACE~ is usually ~zy~.

- ~NAMESPACE/NAME~ :: A public command designed to be used interactively, via =M-x= or a keybinding.
- ~NAMESPACE-NAME~ :: A non-interactive function, or a non-customizable variable.
- ~NAMESPACE$-NAME~ :: A customizable variable.
- ~NAMESPACE--NAME~ :: A protected function or variable.
- ~abc!~ or ~NAMESPACE-abc!~ :: A macro.

* Startup | 啓動

** Early Init

See [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][The Early Init File]].

#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  ;; -*- lexical-binding: t; -*-
  (setq default-frame-alist '(;; Disable menu bar.
                              (menu-bar-lines . nil)
                              ;; Disable scroll bars.
                              (horizontal-scroll-bars . nil)
                              (vertical-scroll-bars . nil)
                              ;; Disable tool bar.
                              (tool-bar-lines . 0))
        menu-bar-mode nil
        scroll-bar-mode nil
        tool-bar-mode nil
        frame-inhibit-implied-resize t
        inhibit-startup-message t
        native-comp-async-report-warnings-errors nil
        package-enable-at-startup nil)
#+end_src

** Startup Timer

#+begin_src emacs-lisp
  (defun display-startup-echo-area-message ()
    (message
     (format "ZyEmacs ready in %.2f seconds."
             (float-time
              (time-subtract after-init-time before-init-time)))))
#+end_src

** Speed Up Startup

Adjust GC and ~file-name-handler-alist~ during startup, to speed up initialisation.

#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5
        --fnha-- file-name-handler-alist
        file-name-handler-alist nil)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 32 1024 1024)
                    gc-cons-percentage 0.1
                    file-name-handler-alist (append file-name-handler-alist
                                                    --fnha--))))
#+end_src

** Load Path

Load the custom file, populate ~load-path~, and deal with autoloads.

#+begin_src emacs-lisp
  ;; Load the custom file.

  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))

  ;; Define the location of custom scripts.

  (defvar zy-lisp-dirs '("lisp" "site-lisp")
    "Directories of ZyEmacs custom lisp scripts.

  Directories are relative to `user-emasc-directory'.")

  (defun zy-get-subdirs-recursively (dir &optional included)
    "Get all subdirectories of DIR recursively.

  If INCLUDED is non-nil, include DIR in the result as well."
    (let ((subdirs (if included `(,dir) nil)))
      (dolist (f (directory-files dir
                                  'full
                                  "^\\([^.]\\|\\.[^.]\\|\\.\\..\\)"
                                  'nosort))
        (when (file-directory-p f)
          (push f subdirs)))
      subdirs))

  ;; Resolve all valid script directories.

  (defvar zy-valid-lisp-dirs
    (let ((subdirs nil))
      (dolist (dir zy-lisp-dirs)
        (setq subdirs
              (append subdirs
                      (zy-get-subdirs-recursively
                       (expand-file-name dir user-emacs-directory)
                       'included))))
      subdirs)
    "All valid directories found in `zy-lisp-dirs', in absolute path.

  A directory being valid means it exists.")

  ;; Populate `load-path'.

  (dolist (dir zy-valid-lisp-dirs)
    (add-to-list 'load-path dir))

  ;; Loaddefs.

  (defvar zy-loaddefs-file (expand-file-name "loaddefs.el"
                                             user-emacs-directory)
    "The path of the loaddefs file.")

  (defun zy/loaddefs-generate ()
    "Generate loaddefs for all my custom scripts."
    (interactive)
    (loaddefs-generate zy-valid-lisp-dirs zy-loaddefs-file))

  (unless (file-exists-p zy-loaddefs-file)
    (zy/loaddefs-generate))
  (load zy-loaddefs-file nil 'nomessage)
#+end_src

** Zy-Block

I utilize the ~zb~ (Zy-Block) macro for configuration grouping. It is like a simpler version of ~use-package~ or ~leaf~, but with my own custom feature set. See ~lisp/zy-block.el~ and ~lisp/zy-benchmark.el~ for its implementation.

#+begin_src emacs-lisp
  (require 'zy-block)
  (setq zb-global-flag-alist
        '((:enable . t)
          (:provide . t)
          (:protect . t)))

  ;; With "--zy-benchmark" option, enable benchmark for all zy-blocks.

  (add-to-list 'command-switch-alist
               '("--zy-benchmark" . (lambda (&rest ignored)
                                      (zbch/show-result))))
  (when (member "--zy-benchmark" command-line-args)
    (push '(:benchmark . t) zb-global-flag-alist))
#+end_src

** Definitions

Personal information and top-level definitions.

#+begin_src emacs-lisp
  (zb init-defs
    ;; Personal information.

    (setq user-full-name "Eric Zhuo Chen"
          user-mail-address "zyxirchen@outlook.com")

    (defgroup zyemacs nil
      "ZyEmacs customization options.")

    ;; Operating system.

    (defconst zy-*windows* (eq system-type 'windows-nt)
      "If Emacs is run on Windows.")

    (defconst zy-*linux* (or (eq system-type 'gnu/linux)
                             (eq system-type 'linux))
      "If Emacs is run on Linux.

  Note that WSL is also Linux.")

    (defun zy-wsl-p ()
      "Return t if ZyEmacs is run on WSL."
      (when zy-*linux*
        (unless (boundp 'zy-wsl-p)
          (setq zy-wsl-p
            (equal
             0
             (call-process "grep" "/proc/version" t nil
                           "-q" "[Mm]icrosoft"))))
        zy-wsl-p))

    ;; Swtiches of ZyEmacs features.

    (defcustom zy$-use-zybox-p t
      "Should ZyEmacs use the workflow designed around Zybox.

  Zybox is private directory of Zyxir, and ZyEmacs has a set of
  utilities to work with Zybox. If you are not Zyxir, do not enable
  this.

  If no valid path of Zybox is detected or set by the user, this
  value will be automatically set to nil.

  Additionally, features like GTD, org-journal and org-roam default
  their file path to specific directories inside Zybox. If Zybox is
  disabled, those features won't load unless another custom path is
  set for them."
      :type 'boolean
      :group 'zyemacs))
#+end_src

** Macros

Some macros I use in this configuration.

#+begin_src emacs-lisp
  (zb init-macros
    (defmacro add-hook! (hook &rest body)
      "Add a lambda function of BODY to the value of HOOK."
      (declare (indent 1) (debug (form def-body)))
      `(add-hook ,hook (lambda () ,@body))))
#+end_src

** Package Management

Manage package with straight.

#+begin_src emacs-lisp
  (zb init-pkg
    ;; Setup straight.el

    (unless (featurep 'straight)
      (defvar bootstrap-version)
      (let ((bootstrap-file
             (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
            (bootstrap-version 5))
        (unless (file-exists-p bootstrap-file)
          (with-current-buffer
              (url-retrieve-synchronously
               "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
               'silent 'inhibit-cookies)
            (goto-char (point-max))
            (eval-print-last-sexp)))
        (load bootstrap-file nil 'nomessage)))
    (setq straight-vc-git-default-clone-depth 1)

    ;; Setup the :pkg keyword for zy-blocks.

    (defun zb-wrapper-pkg--handler (qname pr)
      "Install package according to PR.

  QNAME is the quoted zy-block name, used for issuing warnings.

  Currently, straight.el is used as the package manager. Thus, PR,
  which means package reference, is a straight recipe, or a list of
  straight recipes.

  Return 't' if all packages specified are successfully installed.

  If any of the packages specified is not successfully installed,
  return 'nil'."
      (let ((ret t))
        (if (or (symbolp pr)
                (and (consp pr)
                     (cdr pr)
                     (symbolp (cadr pr))
                     (string-equal (substring
                                    (symbol-name (cadr pr))
                                    0 1)
                                   ":")))
            (setq ret (straight-use-package pr))
          (while pr
            (if (straight-use-package (car pr))
                (setq pr (cdr pr))
              (setq pr nil
                    ret nil))))
        ret))

    (defun zb-wrapper-pkg (name arg body)
      "Execute BODY after package ARG is successfully installed.

  ARG is a package recipe, or a list of recipes."
      ;; Wrap BODY around package conditional.
      `((when (zb-wrapper-pkg--handler ',name ,arg) ,@body)))

    (zb-define-keyword ':pkg 'single #'zb-wrapper-pkg))
#+end_src

* General | 一般性設置

** Autoloads

Recursively update all autoloads under lisp and site-lisp directories, and load autoloads at startup.

#+begin_src emacs-lisp
  (zb init-autoloads
    :enable nil
    ;; A single file for autoloads.

    (defvar zy-loaddefs-file (expand-file-name
                              "loaddefs.el"
                              user-emacs-directory)
      "File containing all autoloads for custom scripts.")

    ;; Autoloads updater.

    (defun zy/autoloads-update ()
      "Update all autoloads for non-package lisp scripts."
      (interactive)
      (require 'loaddefs-gen)
      (let* ((files (apply
                     #'append
                     (mapcar
                      (lambda (dir)
                        (directory-files-recursively dir ".*\\.el"))
                      zy--lisp-dirs))))
        (dolist (file files)
          (let ((generated-autoload-load-name (file-name-base file)))
            (update-file-autoloads file t zy-loaddefs-file))))
      (byte-compile-file zy-loaddefs-file)
      (load zy-loaddefs-file t))

    ;; Load autoloads now.

    (if (file-exists-p zy-loaddefs-file)
        (load zy-loaddefs-file t)
      (zy/autoloads-update)))
#+end_src

** Emacs Server

#+begin_src emacs-lisp
  (zb init-server
    :idle 1
    (require 'server)
    (unless (server-running-p)
      (server-start)))
#+end_src

** Eshell

#+begin_src emacs-lisp
  (zb init-eshell
    (:after-load
     'eshell
     ;; Configuration.
     (setq eshell-scroll-to-bottom-on-input 'all
           eshell-error-if-no-glob t
           eshell-hist-ignoredups t
           eshell-save-history-on-exit t
           eshell-prefer-lisp-functions nil
           eshell-destroy-buffer-when-process-dies t)
     ;; Clear command.
     (defun eshell/clear()
       "Clear the eshell buffer."
       (let ((inhibit-read-only t))
         (erase-buffer)
         (eshell-send-input))))
    (:hook-into
     'eshell-mode-hook
     ;; Disable Corfu completion.
     (setq-local corfu-auto nil)
     ;; Visual executables.
     (dolist (command '("ssh" "tail" "top"))
       (add-to-list 'eshell-visual-commands command))
     ;; Aliases.
     (eshell/alias "e" "find-file $1")
     (eshell/alias "emacs" "find-file $1")
     (eshell/alias "ff" "find-file $1")
     (eshell/alias "ee" "find-file-other-window $1")
     (eshell/alias "ffow" "find-file-other-window $1")))
#+end_src

** Exec Path

Load ~exec-path~ from shell via Purcell's package.

This may take some time, but it is vital for some functionalities.

#+begin_src emacs-lisp
  (zb init-exec-path
    :pkg 'exec-path-from-shell
    (when (memq window-system '(pgtk mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

** External Programs

Open file based on the OS's preference.

#+begin_src emacs-lisp
  (zb init-extapp-os
    ;; OS-specific native function of opening files.
    (defun zy--windows-open (file)
      "Open FILE in Windows native way."
      (w32-shell-execute
       "open"
       (replace-regexp-in-string "/" "\\" fPath t t)))
    (defun zy--linux-open (file)
      "Open FILE in Linux native way."
      (let ((command (if (zy-wsl-p) "wslview" "xdg-open")))
        (call-process command nil nil nil file)))
    (fset 'zy-native-open
      (cond
       (zy-*windows* #'zy--windows-open)
       (zy-*linux* #'zy--linux-open)))

    ;; The interactive command.
    (defun zy/open-in-external-app (&optional file)
      "Open some file in external app.

  The file to open could be FILE if it is not nil or omitted, or
  files marked by dired in `dired-mode', or the current file.

  The app is chosen from the OS's preference."
      (interactive)
      (let* ((flist (cond
                     ((string-equal major-mode "dired-mode")
                      (dired-get-marked-files))
                     ((not file) (list (buffer-file-name)))
                     (file (list file))))
             (do-it (if (<= (length flist) 5)
                        t
                      (y-or-n-p "Open more than 5 files? "))))
        (when do-it
          (mapc #'zy-native-open flist)))))
#+end_src

** Key-Binding

Key-bindings are managed via ~general.el~, and ~which-key~ provides key hints. The leader key of ZyEmacs, which is =M-m= by default, is also defined here.

#+begin_src emacs-lisp
  (zb init-key
    :pkg '(general which-key)
    ;; Setup leader key.

    (defcustom zy$-leader-key "M-m"
      "The leader key of ZyEmacs."
      :type 'key
      :group 'zyemacs)
    (defcustom zy$-leader-key-alternatives '("M-`" "<f5>")
      "A list of alternative leader keys of ZyEmacs."
      :type 'sexp
      :group 'zyemacs)
    (define-prefix-command 'zy-leader-map)
    (general-define-key zy$-leader-key 'zy-leader-map
                        "M-z" 'back-to-indentation)
    (dolist (key zy$-leader-key-alternatives)
      (general-define-key key 'zy-leader-map))

    ;; Disable C-z for GUI.

    (when (display-graphic-p)
      (general-define-key "C-z" nil))

    ;; Setup which-key.

    (which-key-mode +1))

  (zb init-zy-commands
    "Set shortcuts for my custom commands from zy-commands.el."
    :after-load 'init-key
    (general-define-key
     :keymaps 'ctl-x-4-map
     "t" 'zy/transpose-windows))
#+end_src

** Minibuffer

Setup Vertico and other tools.

#+begin_src emacs-lisp
  (zb init-minibuffer
    :pkg '(vertico savehist marginalia orderless
                   consult embark embark-consult)
    ;; Enable modes.
    (vertico-mode +1)
    (savehist-mode +1)
    (marginalia-mode +1)

    ;; Setup Orderless.
    (setq completion-styles '(substring orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion))))

    ;; Other minibuffer settings.
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt)
          enable-recursive-minibuffers t)
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Consult settings.

    (setq completion-in-region-function
          #'consult-completion-in-region)
    (advice-add #'completing-read-multiple
                :override #'consult-completing-read-multiple)

    ;; Consult bindings.

    (general-define-key
     "M-y" 'consult-yank-pop
     "<help> a" 'consult-apropos)

    (general-define-key
     :keymaps 'mode-specific-map
     "h" 'consult-history
     "m" 'consult-mode-command
     "k" 'consult-kmacro)

    (general-define-key
     :keymaps 'ctl-x-map
     "M-:" 'consult-complex-command
     "b" 'consult-buffer
     "4 b" 'consult-buffer-other-window
     "5 b" 'consult-buffer-other-frame
     "r b" 'consult-bookmark
     "p b" 'consult-project-buffer)

    (general-define-key
     :keymaps 'goto-map
     "e" 'consult-compile-error
     "g" 'consult-goto-line
     "M-g" 'consult-goto-line
     "o" 'consult-outline
     "m" 'consult-mark
     "k" 'consult-global-mark
     "i" 'consult-imenu
     "I" 'consult-imenu-multi)

    (general-define-key
     :keymaps 'search-map
     "d" 'consult-find
     "D" 'consult-locate
     "g" 'consult-grep
     "G" 'consult-git-grep
     "r" 'consult-ripgrep
     "l" 'consult-line
     "L" 'consult-line-multi
     "m" 'consult-multi-occur
     "k" 'consult-keep-lines
     "u" 'consult-focus-lines)

    (general-define-key
     :keymaps 'isearch-mode-map
     "M-e" 'consult-isearch-history
     "M-s e" 'consult-isearch-history
     "M-s l" 'consult-line
     "M-s L" 'consult-line-multi)

    (general-define-key
     :keymaps 'minibuffer-local-map
     "M-s" 'consult-history
     "M-r" 'consult-history)

    ;; Embark settings.

    (general-define-key
     "C-." #'embark-act
     "C-;" #'embark-dwim
     "C-h B" #'embark-bindings)
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))
    (add-hook 'embark-collect-mode-hook 'consult-preview-at-point-mode))
#+end_src

** Native Settings

Configuring native Emacs features.

#+begin_src emacs-lisp
  (zb init-native
    (setq
     auto-save-default nil
     case-fold-search nil
     case-replace nil
     disabled-command-function nil
     frame-title-format (if (zy-wsl-p)
                            '("" "ZyEmacs on WSL" " [%b]")
                          '("" "ZyEmacs" " [%b]"))
     inhibit-compacting-font-caches t
     make-backup-files nil
     read-process-output-max (* 1024 1024)
     project-switch-commands '((project-find-file "Find file" "f")
                               (project-find-regexp "Find regexp" "g")
                               (project-find-dir "Find directory" "d")
                               (project-vc-dir "VC-Dir" "v")
                               (project-eshell "Eshell" "s")
                               (magit-project-status "Magit" "m"))
     system-time-locale "C"
     use-dialog-box nil
     word-wrap-by-category t)

    (when (version< "29" emacs-version)
      (setq mouse-drag-and-drop-region-cross-program t))

    (setq-default fill-column 80)

    (add-hook! 'after-init-hook
      (delete-selection-mode +1)
      (global-display-line-numbers-mode +1)
      (global-subword-mode +1)
      (recentf-mode +1)
      (save-place-mode +1)
      (load "kinsoku" 'noerror 'nomessage))

    (dolist (hook '(prog-mode-hook text-mode-hook))
      (add-hook! hook
        (setq-local show-trailing-whitespace t)
        (hl-line-mode +1)
        (auto-revert-mode +1))))
#+end_src

** Restart-Emacs

Restart Emacs within Emacs, or open a new instance of Emacs. This is extremely useful for configuring Emacs.

[2022-03-20 Sun] ~restart-emacs-start-new-emacs~ does not receive prefix arguments, so switch it to a working fork.

#+begin_src emacs-lisp
  (zb init-restart-emacs
    :pkg '(restart-emacs
           :type git
           :host github
           :repo "wyuenho/restart-emacs"
           :branch "patch-1")

    (defun zy/test-config (&optional args)
      "Start a new instance of Emacs to test the configuration.

  This is a handy function for daily configuration: it apply
  `org-babel-tangle-file' on init.org to generate the modified
  configuration, update autoloads, and start a new instance of
  Emacs to test the new configuration, with --debug-init enabled.

  When called interactively ARGS in interpreted as follows

  - with a single `universal-argument' ('C-u'), Emacs is launched
    with '--zy-benchmark' flag to benchmark all zy-blocks.

  When called non-interactively, ARGS is a string or a list of
  string specifying the arguments to start Emacs with."
      (interactive "P")
      (require 'ob)
      (org-babel-tangle-file
       (expand-file-name "init.org" user-emacs-directory))
      (zy/loaddefs-generate)
      (when (file-exists-p zy-loaddefs-file)
        (load zy-loaddefs-file nil 'nomessage))
      (setq args
            (cond
             ((called-interactively-p 'any)
              (when (equal args '(4)) '("--zy-benchmark")))
             ((stringp args)
              (split-string args " "))
             ((consp args)
              args)
             (t nil)))
      (push "--debug-init" args)
      (let ((restart-emacs--inhibit-kill-p t))
        (restart-emacs-start-new-emacs args)))

    (general-define-key
     :keymaps 'zy-leader-map "T" 'zy/test-config))
#+end_src

** Save

#+begin_src emacs-lisp
  (zb init-save
    :pkg 'super-save
    (setq super-save-auto-save-when-idle t)
    (super-save-mode +1))
#+end_src

** WSL

WSL (Windows subsystem for Linux) specific settings.

#+begin_src emacs-lisp
  (zb init-wsl
    :when (zy-wsl-p)
    ;; Make process related functions call Windows commands normally.

    (defun zy-wsl-win-command-p (command)
      "Return if COMMAND is a Windows command."
      (or (equal command "wslview")
          (string-match-p ".exe" command)))

    (defun zy-wsl-arg-convert (program args)
      "Convert Unix paths in ARGS.

  If PROGRAM is a Windows command, convert all path-like argument
  in ARGS to Windows paths."
      (if (zy-wsl-win-command-p program)
          (mapcar
           (lambda (arg)
             (if (equal (zo-path-type arg 'not-a-path) 'unix)
                 (zo-path-to-win arg)
               arg))
           args)
        args))

    (defun zy-wsl-call-process-ad
        (call-process program &optional infile destination display
                      &rest args)
      "Call `call-process' with its arguments filtered for WSL."
      (setq args (zy-wsl-arg-convert program args))
      (apply call-process program infile destination display args))
    (advice-add 'call-process :around #'zy-wsl-call-process-ad))
#+end_src

* Development | 開發

** Flycheck

Modern on-the-fly syntax checking.

#+begin_src emacs-lisp
  (zb init-flycheck
    :pkg 'flycheck
    (add-hook 'prog-mode-hook #'flycheck-mode))
#+end_src

** LSP

Language Server Protocol integration.

#+begin_src emacs-lisp
  (zb init-lsp
    :pkg '(markdown-mode posframe yasnippet)
    (require 'yasnippet)
    (yas-global-mode +1)
    (require 'lsp-bridge)
    (global-lsp-bridge-mode))
#+end_src

** Project Management

A project is a directory under version control. On each of my devices, I place my projects differently, thus I created the following mechanism to manage my projects.

#+begin_src emacs-lisp
  (zb init-proj
    ;; Path of projects.

    (defcustom zy$-projects-path nil
      "Where ZyEmacs should look for projects.

  This variable should be set individually on each machine."
      :type '(repeat directory)
      :group 'zyemacs)

    ;; Easy command to refresh projects.

    (defun zy/projects-refresh ()
      "Refresh project list.

  This function:

  - Load `project.el'.

  - Runs `project-forget-zombie-projects'.

  - Runs `project-remember-projects-under' on every path of
    `zy$-projects-path'."
      (interactive)
      (require 'project)
      (project-forget-zombie-projects)
      (dolist (path zy$-projects-path)
        (project-remember-projects-under path))))
#+end_src

** Tree-Sitter

#+begin_src emacs-lisp
  (zb init-tree-sitter
    "Use tree-sitter in Emacs."
    :pkg '(tree-sitter tree-sitter-langs)
    (require 'tree-sitter)
    (require 'tree-sitter-langs)
    (global-tree-sitter-mode)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src

** Version Control

Version control features of Emacs.

#+begin_src emacs-lisp
  (zb init-diff-hl
    "Show VC status at the fringe."
    :pkg 'diff-hl
    (global-diff-hl-mode)
    :after-load 'magit
    (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

  (zb init-magit
    "Simplify git operations with magit."
    :pkg 'magit
    (general-define-key
     :keymaps 'ctl-x-map
     "g" 'magit-status
     "M-g" 'magit-dispatch))
#+end_src

* Text Editing | 文本編輯

** Incremental Search

Isearch-mb is used to enable using Chinese in isearch. The package has much more
functionalities than this, maybe I shall study it later by reading its [[https://github.com/astoff/isearch-mb/wiki][wiki]].

#+begin_src emacs-lisp
  (zb init-isearch
    :pkg 'isearch-mb
    (setq-default search-ring-max 200
                  regexp-search-ring-max 200
                  isearch-lazy-count t
                  isearch-regexp-lax-whitespace t)
    (isearch-mb-mode +1))
#+end_src

** Moving Around

Moving around text.

#+begin_src emacs-lisp
  (zb init-moving
    ;; Keybinds.
    (general-define-key
     "M-g l" 'goto-line))
#+end_src

** Multiple Cursors

Multiple cursors editing like Visual Studio Code.

#+begin_src emacs-lisp
  (zb init-multiple-cursors
    :pkg 'multiple-cursors
    (general-unbind "M-<down-mouse-1>")
    (general-define-key "M-<mouse-1>" 'mc/add-cursor-on-click))
#+end_src

** Table Alignment

Visually align texts in tables in Markdown mode and Org mode.

#+begin_src emacs-lisp
  (zb init-align
    :pkg 'valign
    (dolist (hook '(org-mode-hook
                    markdown-mode-hook))
      (add-hook hook #'valign-mode)))
#+end_src

** Yasnippet

Turn on ~yas-minor-mode~ in need.

#+begin_src emacs-lisp
  (zb init-yasnippet
    :pkg '(yasnippet yasnippet-snippets)
    ;; Enable yasnippet in need.
    (with-eval-after-load "yasnippet"
      (yas-global-mode +1))
    ;; Disable yasnippet in some modes.
    (defvar zy-yas-disable-hooks '(TeX-mode-hook
                                   LaTeX-mode-hook)
      "Mode hooks where yasnippet should be disabled.")
    (defun zy-yas-turn-off ()
      "Turn off `yas-minor-mode'."
      (yas-minor-mode -1))
    (dolist (hook zy-yas-disable-hooks)
      (add-hook hook #'zy-yas-turn-off))
    ;; Snippet shortcut.
    (autoload 'yas-insert-snippet "yasnippet"
      "Choose a snippet to expand, pop-up a list of choices according
  to ‘yas-prompt-functions’."
      'interactive nil)
    (general-define-key
     "C-c s" #'yas-insert-snippet))
#+end_src

** Unfill Paragraph

Unfilling paragraph or region.

#+begin_src emacs-lisp
  (defun zy/unfill-paragraph (&optional region)
    "Unfill a multi-line paragraph.

  If REGION is not nil, unfill every paragraph in the region."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

  (general-define-key "M-Q" 'zy/unfill-paragraph)
#+end_src

* UI | 用戶界面

** Basic UI Settings

#+begin_src emacs-lisp
  (zb init-ui
    ;; Toggle UI elements.
    (column-number-mode +1)

    ;; UI customization group.
    (defgroup zyemacs-ui nil
      "UI customization options of ZyEmacs."
      :group 'zyemacs))
#+end_src

** Distraction-Free Mode

#+begin_src emacs-lisp
  (zb init-distraction-free
    :pkg 'darkroom
    (setq darkroom-margins 0.1
          darkroom-text-scale-increase 1)
    (general-define-key
     :keymaps 'zy-leader-map
     "d" #'darkroom-mode)
    (add-hook 'darkroom-mode-hook
              (lambda ()
                (let ((inhibit-message t))
                  (delete-other-windows))
                (hl-line-mode 'toggle)
                (unless zy-*windows*
                  (variable-pitch-mode 'toggle))))
    :after-load '(darkroom init-frame-size)
    (defun zy-darkroom-switch-size (&optional frame)
      "Switch FRAME size for `darkroom-mode'.

  All actions below assumes that there is only one window in
  FRAME, and GUI is active. Otherwise, do nothing.

  If 'darkroom-mode' is enabled, and current frame size is
  `zy$-frame-size-standard', resize to `zy$-frame-size-darkroom'.

  If 'darkroom-mode' is disabled, and current frame size is
  `zy$-frame-size-darkroom', resize to `zy$-frame-size-standard'.

  Otherwise, do nothing."
      (when (and (display-graphic-p)
                 (equal (progn
                          (when frame (select-frame frame))
                          (count-windows))
                        1))
        (let* ((width-cur (frame-parameter frame 'width))
               (height-cur (frame-parameter frame 'height))
               (s2d (and (boundp 'darkroom-mode)
                         darkroom-mode
                         (equal width-cur zy$-frame-width-standard)
                         (equal height-cur zy$-frame-height-standard)))
               (d2s (and (not
                          (and (boundp 'darkroom-mode)
                               darkroom-mode))
                         (equal width-cur zy$-frame-width-darkroom)
                         (equal height-cur zy$-frame-height-darkroom))))
          (cond
           (s2d (set-frame-size frame
                                zy$-frame-width-darkroom
                                zy$-frame-height-darkroom))
           (d2s (set-frame-size frame
                                zy$-frame-width-standard
                                zy$-frame-height-standard))
           (t nil)))))
    (add-hook 'darkroom-mode-hook #'zy-darkroom-switch-size)
    (add-to-list 'window-buffer-change-functions
                 #'zy-darkroom-switch-size))
#+end_src

** Font

~lisp/zy-font.el~ provides an abstraction of the basic Emacs font system, which is more practical for Chinese users, via these functions and macros:

- ~zf-set-font-for~
- ~zf-set-font~
- ~zf-font-available-p~
- ~zf-pick-font~

With which the fonts are customized here:

#+begin_src emacs-lisp
  (zb init-font
    :when (display-graphic-p)
    :hook-into 'after-init-hook
    (defcustom zy$-font-mono (zf-pick-font
                              "Sarasa Mono CL"
                              "Consolas"
                              "monospace")
      "Monospace font. Used on most occasions."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-mono-cjk (zf-pick-font
                                  "Sarasa Mono CL"
                                  "Microsoft YaHei"
                                  "monospace")
      "Monospace font for CJK characters and punctuations."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-sans (zf-pick-font
                              "Roboto"
                              "Calibri"
                              "sans-serif")
      "Sans-serif font. Used occasionally."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-sans-cjk (zf-pick-font
                                  "Sarasa Mono CL"
                                  "Microsoft YaHei"
                                  "sans-serif")
      "Sans-serif font for CJK characters and punctuations."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-serif (zf-pick-font
                               "IBM Plex Serif"
                               "Times New Roman"
                               "serif")
      "Serif font. Used occasionally."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-serif-cjk (zf-pick-font
                                   "Source Han Serif K"
                                   "STSong"
                                   "serif")
      "Serif font for CJK characters and punctuations."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-title (zf-pick-font
                               "Roboto Slab Semibold"
                               "sans-serif")
      "Font used for titles."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-title-cjk (zf-pick-font
                                   "Sarasa Mono CL Semibold"
                                   "Microsoft YaHei"
                                   "sans-serif")
      "CJK font used for titles."
      :type 'sexp
      :group 'zyemacs-ui)
    (defcustom zy$-font-size 16
      "Default font size for the UI."
      :type 'integer
      :group 'zyemacs-ui)
    (defcustom zy$-font-size-vp 18
      "Default font size for the 'variable-pitch' face."
      :type 'integer
      :group 'zyemacs-ui)

    ;; Set monospace font as default, and as the fixed pitch font.
    (zf-set-font zy$-font-mono zy$-font-size zy$-font-mono-cjk
                 'default)
    (zf-set-font zy$-font-mono zy$-font-size zy$-font-mono-cjk
                 'fixed-pitch)
    ;; Set serif font as the variable pitch font.
    (zf-set-font zy$-font-serif zy$-font-size-vp zy$-font-serif-cjk
                 'variable-pitch))
#+end_src

** Frame Size

#+begin_src emacs-lisp
  (zb init-frame-size
    (defcustom zy$-frame-width-standard 100
      "Standard frame width for new frames."
      :type 'integer
      :group 'zyemacs-ui)
    (defcustom zy$-frame-height-standard 40
      "Standard frame height for new frames."
      :type 'integer
      :group 'zyemacs-ui)
    (defcustom zy$-frame-width-darkroom 120
      "Standard frame width for Darkroom mode."
      :type 'integer
      :group 'zyemacs-ui)
    (defcustom zy$-frame-height-darkroom 40
      "Standard frame height for Darkroom mode."
      :type 'integer
      :group 'zyemacs-ui)

    (defun zy/resize-frame (&optional frame no-rem)
      "Resize FRAME to standard size.

  If NO-REM is nil or omitted, remember the frame size before
  resize in the 'width-rem' and 'height-rem' frame parameters."
      (interactive)
      (when (display-graphic-p)
        (let* ((width-standard (if (and (boundp 'darkroom-mode)
                                        darkroom-mode)
                                   zy$-frame-width-darkroom
                                 zy$-frame-width-standard))
               (height-standard (if (and (boundp 'darkroom-mode)
                                         darkroom-mode)
                                    zy$-frame-height-darkroom
                                  zy$-frame-height-standard))
               (is-standard (and
                             (= (frame-width) width-standard)
                             (= (frame-height) height-standard)))
               (width-rem (frame-parameter frame 'width-rem))
               (height-rem (frame-parameter frame 'height-rem)))
          (unless (or no-rem is-standard)
            (modify-frame-parameters frame
                                     `((width-rem . ,(frame-width))
                                       (height-rem . ,(frame-height)))))
          (if (and is-standard width-rem height-rem)
              (set-frame-size frame width-rem height-rem)
            (set-frame-size frame width-standard height-standard)))))

    (define-prefix-command 'zy-leader-frame-map)
    (general-define-key
     :keymaps 'zy-leader-map
     "f" 'zy-leader-frame-map)
    (general-define-key
     :keymaps 'zy-leader-frame-map
     "f" 'zy/resize-frame)
    (add-to-list 'after-make-frame-functions
                 #'zy/resize-frame)
    (add-hook 'emacs-startup-hook
              (lambda ()
                (zy/resize-frame nil 'no-rem))))
#+end_src

** Icons

Please run ~all-the-icons-install-fonts~ once.

#+begin_src emacs-lisp
  (zb init-icons
    :when (display-graphic-p)
    :pkg 'all-the-icons)
#+end_src

** Mode Line

#+begin_src emacs-lisp
  (zb init-mode-line
    ;; Hide minor modes that I don't care.
    :pkg 'dim
    :hook-into 'emacs-startup-hook
    (dim-minor-names '((auto-revert-mode nil autorevert)
                       (buffer-face-mode nil face-remap)
                       (eldoc-mode nil eldoc)
                       (flycheck-mode nil flycheck)
                       (lsp-bridge-mode nil lsp-bridge)
                       (lsp-lens-mode nil lsp-lens)
                       (org-indent-mode nil org-indent)
                       (org-roam-ui-follow-mode nil org-roam-ui)
                       (org-roam-ui-mode " ORUI" org-roam-ui)
                       (org-src-mode nil org-src)
                       (reftex-mode nil reftex)
                       (subword-mode nil subword)
                       (super-save-mode nil super-save)
                       (tree-sitter-mode nil tree-sitter)
                       (valign-mode nil valign)
                       (visual-line-mode nil simple)
                       (which-key-mode nil which-key)
                       (wucuo-mode nil wucuo)
                       (yas-minor-mode nil yasnippet))))
#+end_src

** Theme

*** Load Default Theme

#+begin_src emacs-lisp
  (zb init-theme
    (defun zy-theme-func-default ()
      "Default function to setup theme."
      (if (display-graphic-p)
          (progn
            (straight-use-package 'spacemacs-theme)
            (require 'spacemacs-common)
            (load-theme 'spacemacs-light t))
        (load-theme 'wombat t)))
    (defcustom zy$-theme-func #'zy-theme-func-default
      "Function to setup theme."
      :type 'function
      :group 'zyemacs-ui)
    (funcall zy$-theme-func))

  (zb init-solaire
    (defcustom zy$-use-solaire-p t
      "Should ZyEmacs install and enable 'solaire-mode'."
      :type 'boolean
      :group 'zyemacs-ui)
    :when (and zy$-use-solaire-p
               (display-graphic-p))
    :pkg 'solaire-mode
    (solaire-global-mode +1))
#+end_src

*** Theme Hooks

The ~after-enable-theme-hook~ is used to redefine faces after a theme reload.

#+begin_src emacs-lisp
  (zb init-theme-hooks
    (defvar after-enable-theme-hook nil
      "Hook run after a theme is enabled via `enable-theme'.

  `enable-theme' always enables the theme 'user' as well, and that
  won't trigger this hook.

  Note that `load-theme' also runs `enable-theme'.")

    (defun run-after-enable-theme-hook (theme)
      "Run `after-enable-theme-hook'."
      (unless (equal theme 'user)
        (run-hooks 'after-enable-theme-hook)))

    (advice-add #'enable-theme :after #'run-after-enable-theme-hook))
#+end_src

* Lingual | 語言相關
** Symbol Insersion

Easily insert special symbols, such as the "zero width space".

#+begin_src emacs-lisp
  (zb init-sym-ins
    (defun zy/insert-zero-width-space ()
      "Insert a zero-width space at point."
      (interactive)
      (insert #x200b))
    (general-define-key
     :keymaps 'ctl-x-map
     "8 s" #'zy/insert-zero-width-space))
#+end_src

** Encoding

Make everything UTF-8.

#+begin_src emacs-lisp
  (zb init-encoding
    (prefer-coding-system 'utf-8)
    (set-language-environment "UTF-8"))
#+end_src

** OpenCC

[[https://github.com/BYVoid/OpenCC][OpenCC]] is a tool and a library for conversion between traditional and simplified Chinese. [[https://github.com/xuchunyang/emacs-opencc][opencc.el]] integrate OpenCC into Emacs.

#+begin_src emacs-lisp
  (zb init-opencc
    :pkg 'opencc)
#+end_src

** Rime Input Method

#+begin_src emacs-lisp
  (zb init-rime
    :pkg 'rime
    (setq rime-user-data-dir (expand-file-name "rime" user-emacs-directory)
          default-input-method "rime"
          rime-show-candidate 'posframe))
#+end_src

** IM Cursor Color

Change cursor color based on the current input method.

#+begin_src emacs-lisp
  (zb init-im-cursor-color
    (defcustom zy$-im-cursor-color-alist
      '(("rime" . "#f68a06"))
      "Alist of (IM . COLOR) that specifies what cursor color should be
  used for each input method."
      :type 'sexp
      :group 'zyemacs-ui)
    (defvar zy--default-cursor-color (frame-parameter nil 'cursor-color)
      "Default text cursor color.")
    (defun zy--change-cursor-color-on-im ()
      "Set cursor color based on the current active input method."
      (let* ((im-color (alist-get current-input-method
                                  zy$-im-cursor-color-alist
                                  zy--default-cursor-color
                                  nil
                                  'string-equal)))
        (set-frame-parameter nil 'cursor-color im-color)))
    (add-hook 'post-command-hook #'zy--change-cursor-color-on-im))
#+end_src

* Major Modes | 各主模式設置

** Emacs Lisp

#+begin_src emacs-lisp
  (zb init-emacs-lisp
    :hook-into 'emacs-lisp-mode-hook
    (setq-local fill-column 70))
#+end_src

** Miscellaneous

#+begin_src emacs-lisp
  (zb init-json
    :pkg 'json-mode)
#+end_src

** Markdown

#+begin_src emacs-lisp
  (zb init-markdown
    :pkg '(markdown-mode markdown-toc)
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode)))
#+end_src

** Python

#+begin_src emacs-lisp
  (zb init-python
    (setq python-fill-docstring-style 'pep-257-nn)
    :after-load '(python-mode init-lsp)
    ;; AutoPEP8 support.
    (:pkg 'py-autopep8)
    ;; Virtual environment support.
    (:pkg 'pyenv))
#+end_src

** TeX / LaTeX

*** AUCTeX, RefTeX, CDLaTeX

#+begin_src emacs-lisp
  (zb init-tex
     :pkg '(auctex reftex cdlatex)
     :after-load "tex"
     (add-to-list 'TeX-command-list
                  '("XeLaTeX"
                    "%`xelatex%(mode)%' --synctex=1%(mode)%' %t"
                    TeX-run-TeX
                    nil
                    t))
     (setq TeX-auto-save t
           TeX-parse-self t
           TeX-save-query nil)
     (setq-default TeX-engine 'xetex
                   TeX-command-default "XeLaTeX"
                   TeX-master nil
                   font-latex-fontify-script nil
                   TeX-PDF-mode t)

     ;; Ref management with RefTeX.
     (setq reftex-plug-into-AUCTeX t
           reftex-enable-partial-scans t
           reftex-save-parse-info t
           reftex-use-multiple-selection-buffers t)
     (add-hook 'LaTeX-mode-hook 'turn-on-reftex))
#+end_src

*** PDF Preview

#+begin_src emacs-lisp
  (zb init-tex-preview
    "Preview LaTeX PDF."
    :after-load "tex"
    ;; Okular setup.
    (defun zy-latex-preview-okular-setup ()
      "Setup Okular as the LaTeX previewer."
      (add-to-list 'TeX-view-program-list
                   '("Okular" "okular --unique %o#src:%n%b"))
      (setq TeX-view-program-selection '((output-pdf "Okular"))
            TeX-source-correlate-start-server t)
      (TeX-source-correlate-mode +1))
    ;; Assign the solution.
    (cond
     (zy-*linux* (zy-latex-preview-okular-setup))
     (t nil)))
#+end_src

*** Auto Master File

#+begin_src emacs-lisp
  (zb init-tex-master
    "Automatic detection of `TeX-master'."
    :after-load 'init-tex

    (defvar zy-TeX-master-regexp '("main\\.tex" ".*\\.latexmain")
      "Possible patterns of `TeX-master'.")

    (defvar zy-TeX-master-depth 4
      "Maximum level of parent directory to look for `TeX-master'.")

    (defun zy-TeX-find-master ()
      "Find a possible TeX master file."
      (let ((curpath (expand-file-name "./"))
            (curdepth 0)
            foundfiles
            foundfile)
        (while (and (not foundfiles)
                    (not (> curdepth zy-TeX-master-depth)))
          (setq foundfiles (apply
                            #'append
                            (mapcar
                             (lambda (regexp)
                               (directory-files curpath 'full
                                                regexp 'nosort))
                             zy-TeX-master-regexp))
                curpath (expand-file-name ".." curpath)
                curdepth (+ curdepth 1)))
        (and
         (setq foundfile (car foundfiles))
         (file-exists-p foundfile)
         foundfile)))

    (defun zy-TeX-set-master (&rest ignored)
      "Find and set `TeX-master'."
      (setq-local TeX-master (or (zy-TeX-find-master) TeX-master)))

    (advice-add 'TeX-master-file :before #'zy-TeX-set-master))
#+end_src

** Verilog

This section is inspired by [[https://github.com/kaushalmodi][Kaushal Modi]]'s configuration.

#+begin_src emacs-lisp
  (zb init-verilog
    :pkg 'verilog-mode

    ;; After load.
    (:after-load
     'verilog-mode

     ;; Customizations.
     (let ((verilog-indent-level-all 4))
       (dolist (indent '(verilog-indent-level
                         verilog-case-indent))
         (set indent verilog-indent-level-all)))
     (setq verilog-auto-delete-trailing-whitespace t
           verilog-auto-newline nil
           verilog-indent-begin-after-if nil
           verilog-indent-level-behavioral 0
           verilog-indent-level-declaration 0
           verilog-indent-level-module 0))

    ;; Mode hook.
    (:hook-into
     'verilog-mode-hook
     (setq-local fill-column 100)
     (flycheck-mode +1)))
#+end_src

* Org Related | Org 相關

** Basic Org

#+begin_src emacs-lisp
  (zb init-org
    :pkg '(org :type git :host github
	       :repo "bzg/org-mode")
    (setq org-attach-id-dir "_org-att"
	  org-src-window-setup 'current-window
	  org-tags-column 0
	  org-format-latex-options '(:scale 1.2))
    :hook-into 'org-mode-hook
    (display-line-numbers-mode -1)
    (org-indent-mode +1)
    (visual-line-mode +1))

  (zb init-org-appear
    :pkg 'org-appear
    (add-hook 'org-mode-hook 'org-appear-mode)
    (setq-default org-hide-emphasis-markers t))

  (zb init-org-after-load
    :when (display-graphic-p)
    :after-load 'org
    ;; Load some modules.
    (require 'org-attach)
    ;; Faces setup.
    (defun zy--setup-org-faces ()
      "Setup custom faces for org-mode."
      ;; Headline faces.
      (dolist (level (number-sequence 1 8))
	(let ((face (intern (format "org-level-%d" level))))
	  (zf-set-font zy$-font-title nil zy$-font-title-cjk face)
	  (set-face-attribute
	   face
	   nil
	   :height
	   (string-to-number (format "1.%d" (max (- 4 level) 0)))
	   :weight 'semi-bold)))
      ;; Other faces.
      (set-face-attribute 'org-todo nil
			  :foreground 'unspecified
			  :background 'unspecified
			  :weight 'bold
			  :font zy$-font-sans))
    (zy--setup-org-faces)
    (add-hook 'after-enable-theme-hook #'zy--setup-org-faces))
#+end_src

** GTD System

Enable the GTD system when ~zy$-gtd-path~ is valid.

#+begin_src emacs-lisp
  (zb init-gtd
    ;; Determine if GTD should be loaded.
    :after-load 'init-zybox
    (defvar zy-gtd-path
      (cond
       ((boundp 'zy-gtd-path)
        zy-gtd-path)
       (zy$-use-zybox-p
        (expand-file-name "org/org-gtd" zy$-zybox-path))
       (t nil))
      "Where the GTD files are stored.")
    :when zy-gtd-path
    ;; Key-bindings.
    (general-define-key
     :keymaps 'zy-leader-map
     "a" 'org-agenda
     "c" 'org-capture)
    ;; Lazy load other configuration.
    :after-load 'org
    (defvar zy-gtd-inbox-file
      (expand-file-name "inbox.org" zy-gtd-path)
      "The path of \"inbox.org\" of the GTD system.")
    (defvar zy-gtd-gtd-file
      (expand-file-name "gtd.org" zy-gtd-path)
      "The path of \"gtd.org\" of the GTD system.")
    (defvar zy-gtd-someday-file
      (expand-file-name "someday.org" zy-gtd-path)
      "The path of \"someday.org\" of the GTD system.")
    (defvar zy-gtd-files
      `(,zy-gtd-inbox-file ,zy-gtd-gtd-file ,zy-gtd-someday-file)
      "List of all files of the GTD system.")
    ;; Create empty GTD file if not exists.
    (dolist (file zy-gtd-files)
      (unless (file-exists-p file)
        (write-region "" nil file)))
    ;; Settings.
    (setq
     org-log-done 'time
     org-log-refile 'time
     org-agenda-files `(,zy-gtd-inbox-file
                        ,zy-gtd-gtd-file
                        ,zy-gtd-someday-file)
     org-capture-templates `(("i" "inbox" entry
                              (file+headline ,zy-gtd-inbox-file "inbox")
                              "* TODO [#B] %u %i%?"
                              :empty-lines 1)
                             ("s" "someday" entry
                              (file+headline ,zy-gtd-someday-file "someday")
                              "* TODO [#C] %u %i%?"
                              :empty-lines 1)
                             ("t" "GTD" entry
                              (file+olp+datetree ,zy-gtd-gtd-file)
                              "* TODO [#B] %u %i%?"
                              :empty-lines 1))
     org-refile-targets `((,zy-gtd-gtd-file :maxlevel . 3)
                          (,zy-gtd-someday-file :level . 1))
     org-todo-keywords '((sequence "TODO(t)"
                                   "DOING(i)"
                                   "|"
                                   "DONE(d)")
                         (sequence "|"
                                   "CANCELED(c)"))
     org-todo-keyword-faces '(("TODO" .
                               (:inherit org-todo :foreground "#B71C1C"))
                              ("DOING" .
                               (:inherit org-todo :foreground "#8BC34A"))
                              ("DONE" .
                               (:inherit org-todo :foreground "#33691E"))
                              ("CANCELED" .
                               (:inherit org-todo :foreground "#757575"))))
    ;; Per-project TODO.
    (require 'project)
    (when (equal project--list 'unset)
      (project--read-project-list))
    (defvar zy-project-todo-regexp
      "^.*TODO\\.org$"
      "Possible TODO filenames for projects.")
    (dolist (proj project--list)
      (let* ((proj-path (car proj))
             proj-todos)
        (setq proj-todos (directory-files
                          proj-path
                          'full
                          zy-project-todo-regexp
                          'nosort))
        (when proj-todos
          (push (car proj-todos) org-agenda-files)))))
#+end_src

** Org-Download

Org-download provides an alternate method of inserting images in org files.

#+begin_src emacs-lisp
  (zb init-org-download
    :pkg 'org-download
    (setq org-download-method 'directory)
    (setq-default org-download-image-dir "./images"
                  org-download-heading-lvl nil)
    (add-hook 'org-mode-hook (lambda () (require 'org-download))))
#+end_src

** Org-Export

Export settings of various format.

*** Common Export Options

The following elements should only be exported when demanded explicitly: table of contents, tags.

#+begin_src emacs-lisp
  (zb init-ox
    :after-load 'ox
    (setq org-export-with-toc nil
          org-export-with-tags nil))
#+end_src

*** HTML

#+begin_src emacs-lisp
  (zb init-ox-html
    :after-load 'ox-html
    ;; MHTML exporter that embeds images.
    ;; See https://niklasfasching.de/posts/org-html-export-inline-images/
    (defun org-html-export-to-mthml (async subtree visible body)
      (cl-letf (((symbol-function 'org-html--format-image)
                 'format-image-inline))
        (org-html-export-to-html async subtree visible body)))
    (defun format-image-inline (source attributes info)
      (let* ((ext (file-name-extension source))
             (prefix (if (string= "svg" ext)
                         "data:image/svg+xml;base64,"
                       "data:;base64,"))
             (data (with-temp-buffer (url-insert-file-contents source)
                                     (buffer-string)))
             (data-url (concat prefix (base64-encode-string data)))
             (attributes (org-combine-plists
                          `(:src ,data-url) attributes)))
        (org-html-close-tag
         "img"
         (org-html--make-attribute-string attributes)
         info)))
    (org-export-define-derived-backend 'html-inline-images 'html
      :menu-entry '(?h
                    "Export to HTML"
                    ((?m "As MHTML file" org-html-export-to-mhtml)))))
#+end_src

*** LaTeX (PDF)

#+begin_src emacs-lisp
  (zb init-ox-latex
    :after-load 'ox-latex
    ;; Retrieve the "zylatex.sty" file.

    (defvar zy-zylatex-file
      (file-truename
       (expand-file-name "zylatex.sty" user-emacs-directory))
      "Default LaTeX style file to use.")

    (defun zy/ox-latex-update-zylatex-file ()
      "Update the `zy-zylatex-file' from GitHub or Zybox."
      (interactive)
      (let* (ego-found
             std-latex-found
             possible-paths
             path-to-examine
             projet-name)
        ;; Try to find my 'ego' or 'std-latex' repo via project.el.
        (require 'project)
        (when (equal project--list 'unset)
          (project--read-project-list))
        (setq possible-paths project--list)
        (while possible-paths
          (setq path-to-examine (caar possible-paths)
                project-name (file-name-nondirectory
                              (directory-file-name path-to-examine)))
          (cond
           ((equal project-name "std-latex")
            (setq std-latex-found path-to-examine
                  possible-paths nil))
           ((equal project-name "ego")
            (setq ego-found path-to-examine
                  possible-paths nil))
           (t (setq possible-paths (cdr possible-paths)))))
        ;; When something is found, copy zylatex.sty from it, otherwise
        ;; download zylatex.sty from GitHub.
        (cond
         (ego-found
          (copy-file (expand-file-name
                      "std/std-latex/zylatex.sty" ego-found)
                     zy-zylatex-file 'ok-if-already-exists 'keep-time
                     'preserve-uid-gid 'preserve-permissions)
          (message "\"zylatex.sty\" copied from project \"ego\""))
         (std-latex-found
          (copy-file (expand-file-name
                      "zylatex.sty" std-latex-found)
                     zy-zylatex-file 'ok-if-already-exists 'keep-time
                     'preserve-uid-gid 'preserve-permissions)
          (message "\"zylatex.sty\" copied from project \"std-latex\""))
         (t
          (url-copy-file
           "https://raw.githubusercontent.com/zyxir/std-latex/main/zylatex.sty"
           zy-zylatex-file 'ok-if-already-exists)
          (message "\"zylatex.sty\" downloaded.")))))

    (unless (file-exists-p zy-zylatex-file)
      (zy/ox-latex-update-zylatex-file))

    ;; Configure LaTeX exporter.

    (setq org-latex-compiler "xelatex"
          org-latex-default-class "article"
          ;; Delete ".tex" file as well.
          org-latex-logfiles-extensions
          '("aux" "bcf" "blg" "fdb_latexmk" "fls" "figlist" "idx" "log"
            "nav" "out" "ptc" "run.xml" "snm" "tex" "toc" "vrb" "xdv")
          org-latex-classes
          `(;; 自用導出配置，用於個人日誌、散文等。
            ("article"
             ,(format
               "\\documentclass[12pt]{article}
  \\usepackage[]{%s}
  [PACKAGES]
  [EXTRA]" (file-name-sans-extension zy-zylatex-file))
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            (;; 適合手機屏幕閱讀的配置。
             "article-phone"
             ,(format
               "\\documentclass[12pt]{article}
  \\usepackage[layout=phone]{%s}
  [PACKAGES]
  [EXTRA]" (file-name-sans-extension zy-zylatex-file))
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
            (;; 適用於簡體中文的配置。
             "article-sc"
             ,(format
               "\\documentclass[12pt]{article}
  \\usepackage[style=tc, fontset=ctex]{%s}
  [PACKAGES]
  [EXTRA]" (file-name-sans-extension zy-zylatex-file))
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))

    ;; Export smartphone-friendly PDF.

    (defun zy-org-latex-export-to-pdf-phone
        (&optional async subtreep visible-only body-only ext-plist)
      "Export current buffer to smartphone-friendly PDF.

  The function works like `org-latex-export-to-pdf', except that
  `org-latex-default-class' is set to \"article-phone\"."
      (let ((org-latex-default-class "article-phone"))
        (org-latex-export-to-pdf async subtreep visible-only
                                 body-only ext-plist)))
    (org-export-define-derived-backend 'latex-pdf-phone 'latex
      :menu-entry '(?l
                    "Export to LaTeX"
                    ((?j "As PDF file (phone-friendly)"
                         zy-org-latex-export-to-pdf-phone)))))
#+end_src

** Org-Superstar

#+begin_src emacs-lisp
  (zb init-org-superstar
    :when (display-graphic-p)
    :pkg 'org-superstar
    (add-hook 'org-mode-hook 'org-superstar-mode)
    (setq org-superstar-headline-bullets-list '(#x25c9
                                                #x25cb
                                                #x25c8
                                                #x25c7
                                                #x2666)
          org-superstar-cycle-headline-bullets nil
          org-hide-leading-stars nil
          org-superstar-leading-bullet #x200b
          org-indent-mode-turns-on-hiding-stars nil
          org-superstar-item-bullet-alist '((42 . #x2605)
                                            (43 . #x2666)
                                            (45 . #x27a4)))
    :after-load 'org-superstar
    (dolist (face '(org-superstar-header-bullet
                    org-superstar-item
                    org-superstar-leading))
      (zf-set-font zy$-font-mono nil nil face)))
#+end_src

** Org-Journal

#+begin_src emacs-lisp
  (zb init-org-journal
    :after-load 'init-zybox
    (setq org-journal-dir
          (cond
           ((boundp 'org-journal-dir)
            org-journal-dir)
           (zy$-use-zybox-p
            (expand-file-name "org/org-journal" zy$-zybox-path))
           (t nil)))
    :when org-journal-dir
    :pkg 'org-journal
    (general-define-key
     :keymaps 'zy-leader-map
     "g" 'calendar
     "j" 'org-journal-new-entry)
    (setq org-journal-extend-today-until 3
          org-journal-file-format "%F.org"
          org-journal-date-format "%F %a W%V\n"
          org-journal-date-prefix "#+title: "
          org-journal-time-format "%R "
          org-journal-time-format-post-midnight "%R (midnight) "
          org-journal-time-prefix "\n* "
          org-journal-file-header ""))
#+end_src

** Org-Roam

*** Basic Setup

Load org-roam when ~org-roam-directory~ is valid.

#+begin_src emacs-lisp
  (zb init-org-roam
    :after-load 'init-zybox
    (setq org-roam-directory
          (cond
           ((boundp 'org-roam-directory)
            org-roam-directory)
           (zy$-use-zybox-p
            (expand-file-name "org/org-roam" zy$-zybox-path))
           (t nil)))
    :when org-roam-directory
    :pkg 'org-roam
    (define-prefix-command 'zy-leader-roam-map)
    (general-define-key
     :keymaps 'zy-leader-map
     "r" 'zy-leader-roam-map)
    (general-define-key
     :keymaps 'zy-leader-roam-map
     "i" 'org-roam-node-insert
     "f" 'org-roam-node-find
     "c" 'org-roam-capture
     "a" 'org-roam-alias-add
     "l" 'org-roam-buffer-toggle)
    :after-load 'org-roam
    (org-roam-db-autosync-mode))
#+end_src

*** Org-Roam-UI

#+begin_src emacs-lisp
  (zb init-org-roam-ui
    :pkg 'org-roam-ui
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t)
    ;; Open or close it with command.
    (defun zy/roam-ui-dwim ()
      "Do what I mean with `org-roam-ui-mode'.

  Without 'C-u' prefix, this function works as `org-roam-ui-open'.

  With one 'C-u' prefix, this function turns off `org-roam-ui-mode'"
      (interactive)
      (if (equal current-prefix-arg nil)
          (org-roam-ui-open)
        (org-roam-ui-mode -1)))
    (general-define-key
     :keymaps 'zy-leader-roam-map
     "u" 'zy/roam-ui-dwim))
#+end_src

** Markup

Chinese words are not separated by spaces, which cause trouble for org-mode. These commands allow surrounding texts with markup symbols as well as zero width spaces, making it easier for Chinese text markup. See [[https://emacs-china.org/t/org-mode/597/49][this post]] for more.

#+begin_src emacs-lisp
  (zb init-org-markup
    :after-load 'org
    (defvar zy-org-surround-docstring-template
      "Insert \"%s\" smartly.

  If there is no active region, call `org-self-insert-command';
  otherwise, surround the region with \"%s\", and insert zero-width
  space if there is no space before or after the region."
      "Template docstring for `zy-org-surround'.")
    (defun zy-whitespace-p (char)
      "Return t if CHAR is whitespace character, or nil otherwise."
      (or (equal char ?\t)
          (equal char ?\n)
          (equal char ?\s)
          (equal char #x200b)))
    (defmacro zy-org-surround (&rest keys)
      "Bind KEYS for org-mode markup surrounding.

  Each key in KEYS will have a new functionality: if no region is
  active, it inserts the symbol as exptected; but if there is an
  active region, it surrounds the region with the key, and insert
  zero-width space if there is no space before or after the region,
  to make the markup actually work."
      (let ((body nil)
            cmdname
            docstring)
        (dolist (key keys)
          (setq cmdname (intern (concat "zy/org-maybe-surround-" key))
                docstring (format
                           zy-org-surround-docstring-template key key))
          (push `(defun ,cmdname ()
                   ,docstring
                   (interactive)
                   (if (region-active-p)
                       (let ((beg (region-beginning))
                             (end (region-end)))
                         (save-excursion
                           (goto-char end)
                           (insert ,key)
                           (unless (zy-whitespace-p
                                    (following-char))
                             (insert-char #x200b))
                           (goto-char beg)
                           (unless (zy-whitespace-p
                                    (char-before))
                             (insert-char #x200b))
                           (insert ,key)))
                     (call-interactively #'org-self-insert-command)))
                body)
          (push `(general-define-key
                  :keymaps 'org-mode-map
                  ,key #',cmdname)
                body))
        (setq body (nreverse body))
        (push 'progn body)
        body))
    (zy-org-surround "~" "=" "*" "/" "_" "+" "$"))
#+end_src

* Features | 功能

** Bibliography Management

*** Top Level

Some top level definitions. My bibliography database is managed by Zotero.

#+begin_src emacs-lisp
  (zb init-bib
    :after-load 'init-zybox
    :when zy$-use-zybox-p
    (defvar zy-bib-dir (expand-file-name "zotero" zy$-zybox-path)
      "Where all bibliography files are located.")
    (defvar zy-bib-files-relative '("references.bib")
      "Names of bibliography files, relative to `zy-bib-dir'.")
    (defvar zy-bib-files (mapcar
                          (lambda (file)
                            (expand-file-name file
                                              zy-bib-dir))
                          zy-bib-files-relative)
      "Names of bibliography files."))
#+end_src

*** Citar

Inserting and managing org-cite style citations with citar.

#+begin_src emacs-lisp
  (zb init-citar
    :after-load 'init-zybox
    :when zy$-use-zybox-p
    :pkg 'citar
    (setq citar-bibliography zy-bib-files)
    (general-define-key
     "C-c c" #'citar-insert-citation)
    (general-define-key
     :keymaps 'minibuffer-local-map
     "C-c C" #'citar-insert-preset)

    ;; Overwrite citar functions to correctly locate files in Zotero
    ;; BibTeX database.
    :after-load 'citar

    (defun zy--citar-file-parser-wsl (dirs file-field)
      "Return a list of files from FILE-FIELD.

  All Windows paths will be converted to WSL paths.

  DIRS is ignored."
      (let ((files (split-string file-field ";")))
        (mapcar #'zo-path-to-wsl files)))
    (setq citar-file-parser-functions '(zy--citar-file-parser-wsl))

    (defun zy--citar-file--files-for-multiple-entries
        (key-entry-alist dirs extensions)
      "Almost same as `citar-file--files-for-multiple-entries'.

  However, this function extract file entries from a Zotero BibTeX entry."
      (let* ((keys (seq-map #'car key-entry-alist)))
        (delete-dups
         (seq-mapcat
          (lambda (key-entry)
            (append
             (seq-filter #'file-exists-p
                         (citar-file--parse-file-field
                          (cdr key-entry)
                          citar-file-variable nil nil))))
          key-entry-alist))))
    (advice-add 'citar-file--files-for-multiple-entries :override
                #'zy--citar-file--files-for-multiple-entries)

    (defun zy--citar-open-library-file (key-entry)
      "Open library file associated with the KEY-ENTRY.

  This function is intended to open absolute Windows paths in WSL,
  so it do not check for `citar-library-paths'.

  With prefix, rebuild the cache before offering candidates."
      (interactive (list (citar-select-ref
                          :rebuild-cache current-prefix-arg)))
      (let ((embark-default-action-overrides '((file . citar-file-open))))
        (citar--library-file-action key-entry 'open)))
    (advice-add 'citar-open-library-file :override
                #'zy--citar-open-library-file)

    (advice-add 'citar-file-open :override #'zy/open-in-external-app))
#+end_src

** File Management

Install Dirvish, an improved version of Dired.

#+begin_src emacs-lisp
  (zb init-dirvish
    :pkg 'dirvish
    (dirvish-override-dired-mode)
    :after-load 'dirvish
    (setq delete-by-moving-to-trash t
          dired-listing-switches
          "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group"
          dirvish-attributes '(vc-state
                               subtree-state
                               collapse
                               all-the-icons
                               file-time
                               file-size))
    (custom-set-variables
     `(dirvish-quick-access-entries
       `(("h" "~/" "Home")
         ("e" "~/.emacs.d/" "Emacs user directory")
         ("p" ,(car zy$-projects-path) "Zyproject"))
       nil 'dirvish-quick-access))
    (when (version< "29" emacs-version)
      (setq dired-mouse-drag-files t)))
#+end_src

** Zybox

Zybox is the collection of my personal files.

#+begin_src emacs-lisp
  (zb init-zybox
    (defcustom zy$-zybox-path nil
      "The path of Zybox, the collection of all my files.

  If it is not auto-detected, customize it to the actual path."
      :type 'directory
      :group 'zyemacs)

    (defun zy--find-zybox ()
      "Try to auto-detect the location of Zybox."
      (let* ((zybox-possible-locs-windows
              '("C:\\Zybox"
                "C:\\Users\\zyxir\\Zybox"
                "C:\\Users\\zyxir\\Documents\\Zybox"))
             (zybox-possible-locs-linux
              '("~/Zybox"
                "~/Documents/Zybox"
                "/mnt/c/Zybox"
                "/mnt/c/Users/zyxir/Zybox"
                "/mnt/c/Users/Documents/Zybox"))
             (zybox-possible-locs
              (cond
               (zy-*windows* zybox-possible-locs-windows)
               (zy-*linux* zybox-possible-locs-linux)
               (t nil)))
             loc-to-examine
             path-found)
        (while zybox-possible-locs
          (setq loc-to-examine (car zybox-possible-locs))
          (if (file-directory-p loc-to-examine)
              (setq path-found loc-to-examine
                    zybox-possible-locs nil)
            (setq zybox-possible-locs
                  (cdr zybox-possible-locs))))
        (if path-found
            (lwarn 'zyemacs :warning
                   "Zybox is auto-detected at %s." path-found)
          (lwarn 'zyemacs :warning "Could not auto-detect Zybox."))
        path-found))

    (when (and zy$-use-zybox-p
               (not zy$-zybox-path))
      (setq zy$-zybox-path (zy--find-zybox))
      (if zy$-zybox-path
          (customize-save-variable 'zy$-zybox-path zy$-zybox-path)
        (customize-save-variable 'zy$-use-zybox-p nil))))
#+end_src

* Bug Fixes | Bug 修復

** F.el

Fix the "No such file or directory: f-shortdoc" problem.

#+begin_src emacs-lisp
  (add-to-list 'load-path
               (expand-file-name "straight/repos/f.el"
                                 user-emacs-directory))
#+end_src
